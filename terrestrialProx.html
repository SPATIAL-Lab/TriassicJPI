<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Gabriel Bowen">
<meta name="dcterms.date" content="2025-05-08">

<title>Terrestrial Proxies</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="terrestrialProx_files/libs/clipboard/clipboard.min.js"></script>
<script src="terrestrialProx_files/libs/quarto-html/quarto.js"></script>
<script src="terrestrialProx_files/libs/quarto-html/popper.min.js"></script>
<script src="terrestrialProx_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="terrestrialProx_files/libs/quarto-html/anchor.min.js"></script>
<link href="terrestrialProx_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="terrestrialProx_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="terrestrialProx_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="terrestrialProx_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="terrestrialProx_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Terrestrial Proxies</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Gabriel Bowen </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 8, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Let’s review the high-latitude (terrestrial) proxy data and its interpretation. I’ll refer to the sites by number for convenience, here’s the key:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Carnian = pink"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>              Site lat_mean lat_min lat_max
1      Los_Rastros    45.64   42.70   48.58
2 Badong-Jiuligang    20.00   10.00   30.00
3         Chanares    45.64   42.70   48.58
4    Ischigualasto    47.44   45.00   50.00
5           Poland    25.02   22.09   28.20
6     Dp_Morsleben    25.26   23.01   27.51
7  Central_Germany    23.96   21.70   26.21
8         Tasmania    70.61   68.38   72.88</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Anisian = blue"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>         Site lat_min lat_max lat_mean
1     Puntudo   37.81   48.43   43.120
2  Las_Cabras   39.76   50.41   45.085
3        Utah    5.00   15.00   10.000
4   Australia   58.92   69.91   64.340
5       India   39.49   50.16   44.700
6 Santa_Clara   39.01   49.64   44.325
7  Antarctica   72.82   78.62   75.690</code></pre>
</div>
</div>
<section id="alsi" class="level2">
<h2 class="anchored" data-anchor-id="alsi">Al/Si</h2>
<p>Al/Si is available from 4 Carnian sites and 1 Anisian site. Here I’m plotting the calibration data set for the proxy (black) and the paleo-proxy values vs.&nbsp;the posterior median site MAT (pink = Carnian, blue = Anisian).</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="terrestrialProx_files/figure-html/alsi-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>My observations:</p>
<ul>
<li>The data are very noisy.</li>
<li>The posterior Carnian MATs skew a little bit cooler than you would get if you used these data alone, but are not too dissimilar on average.</li>
<li>Carnian site 3 (Chanares) stands out as having reconstructed MAT substantially lower than the Al/Si would imply, alone.</li>
</ul>
</section>
<section id="cia" class="level2">
<h2 class="anchored" data-anchor-id="cia">CIA</h2>
<p>Same thing for CIA, which is available at 4 Carnian and 3 Anisian sites.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="terrestrialProx_files/figure-html/CIA-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<ul>
<li>In this case, the posterior MATs for some sites tend to be a little higher than you’d expect just based on the proxy data (top/right).</li>
<li>The MATs for the new Antarctic site plot just slightly cold compared with what you’d expect based on the CIA values.</li>
<li>It’s a really weak proxy (huge scatter in the calibration data) so not surprising that here, too, there’s not a a very strong influence on the MATs.</li>
</ul>
</section>
<section id="pwi" class="level2">
<h2 class="anchored" data-anchor-id="pwi">PWI</h2>
<p>Now paleosol weathering index, available at one Anisian and two Carnian sites. I’ve added the calibration curve using the median curve fit parameters in the posterior for reference.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="terrestrialProx_files/figure-html/PWI-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Here the reconstructions fit the calibration data well. Obviously the interpretation is based on an extrapolation at site 3, but if one takes the proxy at face value it’s pretty tough for this site to have a MAT higher than, say, 5 or 10 <span class="math inline">\(^\circ\)</span>. Note that this is the same site which has a cool bias in the first plot (based on Al/Si).</p>
<p>The MAT for the new Antarctic site is slightly higher than expected based just on PWI (compare w/ the CIA result).</p>
</section>
<section id="clumped" class="level2">
<h2 class="anchored" data-anchor-id="clumped">Clumped</h2>
<p>Here I’m using the calibration function from Julia Kelson’s paper, which is represented as a line. Only one Anisian site.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="terrestrialProx_files/figure-html/clumped-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<ul>
<li>The JPI posterior is a little warm at this site for what you’d expect accounting for seasonality. The closed symbols are MAT, the open ones are summer temperature.</li>
<li>Note that this same site has a bunch of CIA data shown above, and the posterior MAT is also a bit warmer than expected given those data. This is a sub-tropical site, and the fairly warm SSTs are pulling the MAT values at this and other sub-tropical Anisian sites toward higher values.</li>
</ul>
</section>
<section id="oxygen-isotopes" class="level2">
<h2 class="anchored" data-anchor-id="oxygen-isotopes">Oxygen isotopes</h2>
<p>I’m using carbonate <span class="math inline">\(\delta^{18}O\)</span> data from 2 Carnian and 4 Anisian sites. The lines on the plot show predicted average continental carbonate values as a function of temperature for the model prior (black) and posteriors (colors as throughout). This is derived in two steps:</p>
<ul>
<li>Precipitation <span class="math inline">\(\delta^{18}O\)</span> value is a function of temperature. The prior uses the classic modern empirical relationship. The slope and intercept of the relationship are model parameters which are sampled separately and optimized for each stage.</li>
<li>Carbonate <span class="math inline">\(\delta^{18}O\)</span> value is a function of the local precipitation <span class="math inline">\(\delta^{18}O\)</span> value and temperature. Previously we had been using MAT to describe fractionation in this step, which is reflected in the solid lines below. Now we’re using summer season temperature. Because the relationship between MAT and summer temperature is a function of both MAT and latitude we can’t plot a single line representing this, but I’ve approximated the relationship by plotting the predicted carbonate <span class="math inline">\(\delta^{18}O\)</span> values using summer season temperature for a site at 45<span class="math inline">\(^\circ\)</span> latitude (dotted lines).</li>
</ul>
<p>The data are plotted as above, with the posterior median MAT on the x axis and the measured proxy value on the y axis.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="terrestrialProx_files/figure-html/oxygen-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>The big take-home here is that terrestrial carbonate <span class="math inline">\(\delta^{18}O\)</span> values are low relative to the prior, especially at the warmer sites. Most of the values would be consistent with MATs below freezing. Accounting for seasonality reduces this effect, because mineral precipitation at warmer summer temperatures produces calcite with lower <span class="math inline">\(\delta^{18}O\)</span>. Even then, however, some of the data (especially for Anisian sub-tropical sites, e.g., sites 2 and 6) would imply pretty low MAT (near or just below zero).</p>
<p>The model accommodates this by changing the relationship between MAT and precipitation <span class="math inline">\(\delta^{18}O\)</span> values for the Anisian…precipitation <span class="math inline">\(\delta^{18}O\)</span> at any given MAT is 1-2 per mil lower in the Anisian than the modern or the Carnian (where the data are more consistent w/ the modern precipitation isotope gradient, after accounting for temperature seasonality)</p>
</section>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>Univariate interpretations of the terrestrial proxy data at all sites <em>except</em> Utah suggest MATs no higher than 20<span class="math inline">\(^\circ\)</span>. Adding variable <span class="math inline">\(\delta^{18}O\)</span> of seawater and the data from the Antarctic site has pulled the Anisian continental temperatures at all latitudes up, so that in most cases they are at the higher end of the ranges suggested by the terrestrial proxy data. Temperatures for the Carnian tend to remain a compromises, with Al/Si values pulling these temperatures warmer and CIA values suggesting lower MATs than reflected in the JPI posterior.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>