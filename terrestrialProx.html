<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Gabriel Bowen">
<meta name="dcterms.date" content="2025-07-02">

<title>Terrestrial Proxies</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="terrestrialProx_files/libs/clipboard/clipboard.min.js"></script>
<script src="terrestrialProx_files/libs/quarto-html/quarto.js"></script>
<script src="terrestrialProx_files/libs/quarto-html/popper.min.js"></script>
<script src="terrestrialProx_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="terrestrialProx_files/libs/quarto-html/anchor.min.js"></script>
<link href="terrestrialProx_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="terrestrialProx_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="terrestrialProx_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="terrestrialProx_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="terrestrialProx_files/libs/bootstrap/bootstrap-1bc8a17f135ab3d594c857e9f48e611b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Terrestrial Proxies</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Gabriel Bowen </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 2, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Let’s review the high-latitude (terrestrial) proxy data and its interpretation. I’ll refer to the sites by number for convenience, here’s the key:</p>
<div class="cell">
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Carnian = pink"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>               Site lat_mean   lat_min  lat_max
1       Los_Rastros 43.19176 41.000775 45.50344
2  Badong-Jiuligang 23.38095 21.197360 25.70490
3          Chanares 43.48715 41.295825 45.79841
4     Ischigualasto 43.40489 41.213670 45.71629
5            Poland 26.63423 24.451705 28.95877
6      Dp_Morsleben 25.18959 23.006570 27.51387
7  Neubrandenburg_2 27.01635 24.834160 29.34108
8        Am_Hohnert 23.88488 21.700895 26.20846
9          Tasmania 70.57833 68.351085 72.84946
10  WHAtlas_Morocco  9.58142  7.366845 11.87562</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Anisian = blue"</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>         Site  lat_min  lat_max lat_mean
1     Puntudo 40.11527 45.62814 42.78801
2  Las_Cabras 41.92848 47.44075 44.60393
3        Utah 11.08202 16.60424 13.76430
4   Australia 64.11139 69.61877 66.82359
5       India 41.66384 47.17643 44.33814
6 Santa_Clara 41.16573 46.67825 43.84002
7  Antarctica 73.82809 79.33444 76.55695</code></pre>
</div>
</div>
<section id="alsi" class="level2">
<h2 class="anchored" data-anchor-id="alsi">Al/Si</h2>
<p>Below I’m plotting the calibration data set for the proxy (black) and the paleo-proxy values vs.&nbsp;the posterior median site MAT (pink = Carnian, blue = Anisian).</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="terrestrialProx_files/figure-html/alsi-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<ul>
<li>The data are very noisy.</li>
<li>Al/Si values for all the Carnian sites are similar. Because of the influence of other proxies some have posterior MATs that fall below and others above the values you would estimate from Al/Si alone.</li>
<li>The one Anisian site has a MAT estimate ~3 <span class="math inline">\(^\circ\)</span>C hotter than what would be estimated from MAT alone.</li>
</ul>
</section>
<section id="cia" class="level2">
<h2 class="anchored" data-anchor-id="cia">CIA</h2>
<p>Same thing for CIA.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="terrestrialProx_files/figure-html/CIA-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<ul>
<li>Posterior MATs are pretty consistent with the proxy values, within the range of proxy uncertainty.</li>
<li>On average, posterior MATs are slightly higher at all Carnian sites than would be predicted from CIA values alone…this proxy is pulling temperatures down.</li>
</ul>
</section>
<section id="pwi" class="level2">
<h2 class="anchored" data-anchor-id="pwi">PWI</h2>
<p>Now paleosol weathering index, available at one Anisian and two Carnian sites. I’ve added the calibration curve using the median curve fit parameters in the posterior for reference.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="terrestrialProx_files/figure-html/PWI-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Here the reconstructions fit the calibration data well. Obviously the interpretation is based on an extrapolation at Carnian site 3, but if one takes the proxy at face value it’s pretty tough for this site to have a MAT higher than, say, 5 or 10 <span class="math inline">\(^\circ\)</span>. Note that this same site has a cool bias in the first plot (based on Al/Si).</p>
</section>
<section id="clumped" class="level2">
<h2 class="anchored" data-anchor-id="clumped">Clumped</h2>
<p>Here I’m using the calibration function from Julia Kelson’s paper, which is represented as a line. Only one Anisian site.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="terrestrialProx_files/figure-html/clumped-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<ul>
<li>The JPI posterior is a little warm at this site for what you’d expect accounting for seasonality. The closed symbols are MAT, the open ones are summer temperature.</li>
<li>Note that this same site has a bunch of CIA data shown above, and the posterior MAT is also a bit warmer than expected given those data. This is a sub-tropical site, and the fairly warm SSTs are pulling the MAT values at this and other sub-tropical Anisian sites toward higher values.</li>
</ul>
</section>
<section id="oxygen-isotopes" class="level2">
<h2 class="anchored" data-anchor-id="oxygen-isotopes">Oxygen isotopes</h2>
<p>I’m using carbonate <span class="math inline">\(\delta^{18}O\)</span> data from 3 Carnian and 4 Anisian sites. The lines on the plot show predicted average continental carbonate values as a function of temperature for the model prior (black) and posteriors (colors as throughout). This is derived in two steps:</p>
<ul>
<li>Precipitation <span class="math inline">\(\delta^{18}O\)</span> value is a function of temperature. The prior uses the classic modern empirical relationship. The slope and intercept of the relationship are model parameters which are sampled separately and optimized for each stage.</li>
<li>Carbonate <span class="math inline">\(\delta^{18}O\)</span> value is a function of the local precipitation <span class="math inline">\(\delta^{18}O\)</span> value and temperature. Previously we had been using MAT to describe fractionation in this step, which is reflected in the solid lines below. Now we’re using summer season temperature. Because the relationship between MAT and summer temperature is a function of both MAT and latitude we can’t plot a single line representing this, but I’ve approximated the relationship by plotting the predicted carbonate <span class="math inline">\(\delta^{18}O\)</span> values using summer season temperature for a site at 45<span class="math inline">\(^\circ\)</span> latitude (dotted lines).</li>
</ul>
<p>The data are plotted as above, with the posterior median MAT on the x axis and the measured proxy value on the y axis.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="terrestrialProx_files/figure-html/oxygen-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Here again we have a mix. The Anisian sites, where there is limited non-isotope terrestrial proxy data (only site 1 has other data) tend to have relatively warm posterior MATs for their <span class="math inline">\(\delta^{18}O\)</span> values. For the Carnian sites, the new one from Morocco (site 10) stands out as the clear outlier…very high oxygen isotope values and a low MAT. This is driven by the CIA data from this site, which prefer a lower MAT. The CIA wins out because the oxygen isotope model has more degrees of freedom - site level temperature and precipitation <span class="math inline">\(\delta^{18}O\)</span> can both adjust to accomodate the higher carbonate isotope values, whereas the only freedom in the CIA proxy model is the uncertainty in the calibration relationship.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>